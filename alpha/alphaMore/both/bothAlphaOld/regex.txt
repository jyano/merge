  construct rx:   (1)   rx lit   /ab+c/  provide compilation of the rx on script load,   better performance if rx const
    (2)    RegExp ob constructor fn     new RegExp("ab+c")   provides runtime compilation, use when pt changing|?


 simp lit  /abc/  ==  chars 'abc' together
 *  0+ occ of prec item         /ab*c/  = *  char comb in which a single 'a' is followed by 0+ 'b's,
  then imm folby 'c'.      "cbbabbbbcdebc" M  'abbbbc'
  '\' that precedes a !spc char:   next char is spec (!lit)   '\b'!M any char, forms spc wB char
   '\'   preceding   spcl char: the next char   !spc            \ must esc itself

             /a*/ relies on  spc char '*' to mat  0+  a's            /a\*/ de-spc  '*' ,   M 'a*'
  ^	== beg  of ip.    If   mltln   true,    M imm  af  line break char.        /^A/      !M 'A' in "an A",      M   'A' in "An E".
     $  = end of input.   if mltln   true,   mats imm  bf   line break char.      /t$/       !M 't' in "eater",  M it in "eat".
      *  ~ {0,} mats prcd  char 0+      /bo*/      'boooo' M "A ghost booooed"      'b' M "A bird warbled"     !M "A goat grunted"
 + ~ {1,}  mats the prec  char 1+      /a+/      M 'a'/"candy",  M all the a's in "caaaaaaandy",  !M "cndy".
     ?	~ {0,1} mats the prec  char 0|1 time       /e?le?/ M 'el' | "angel"    M   'le' | "angle"    M 'l' |"oslo"
     if used imm aft  *  quantifiers  ( *   +   ?  {  } )  non-greedifies quantifier    (matg LEAST)  (df is greedy (mat  as MANY chars as poss ))
 appg /\d+/ to "123abc"  M "123"  but appg /\d+?/ to that same str M "1".

 .  == any sing char !newline char          /.n/  M  ('an' , 'on') | "nay an apple is on the tree", !M 'nay'.
   capturing    (x)      M 'x', rems mat    The '(foo)' and '(bar)' in the pt /(foo) (bar) \1 \2/   mat,    rem 1st two words in the str "foo bar foo bar".
     \1 and \2 in   pt mat  str's last two words    \1, \2, \n are used in the matchg part of the rx
       In the replacement part of a regex the syntax  $1, $2, $n must be used    'bar foo'.replace( /(...) (...)/, '$2 $1' ).
 (?:x) Mats 'x' but !rem  the mat  The '()' are called !cap'()' &  let you df subexpressions for rx operators to work with.
  /(?:foo){1,2}/.   If expr was /foo{1,2}/,
   {1,2} chars  apply only to   last 'o' in 'foo'.
 	   With the !cap'()',  the {1,2} appls to entire word 'foo'.
   lookahead    x(?=y)  Mats 'x'   if 'x' is folld by 'y'
       /Jack(?=Sprat)/    mats 'Jack'  if folld by 'Sprat'           /Jack(?=Sprat|Frost)/
       mats 'Jack'  if it is foll  by 'Sprat' | 'Frost'     !M 'Sprat' , 'Frost'
         neg lookahead    x(?!y)       'x' if 'x' !folld by 'y'.    /\d+(?!\.)/   mats  num  onlif !folld by a dec  pt
      /\d+(?!\.)/.exec("3.141")   M'141', !M  '3.141'
     x|y   ==  'x' or 'y'.     /green|red/     M 'green' | "green apple" , 'red' | "red apple."
 {n}	M exactly n occ of the precg char    N must be +int .
 /a{2}/  doesn't match the 'a' in "candy," M all of the a's in "caandy,"    M 1st two a's in "caaandy."
 {n,m} Where n and m are pos ints and n <= m.  M at least n and at most m occ  of  prec  char  When m is omitted,
  it's treated as ∞

   /a{1,3}/  !M "cndy",M'a' |"candy,"   M 1st two a's in "caandy,"    M 1st three a's in "caaaaaaandy".
    when matg "caaaaaaandy",  M = "aaa",   even though orig str > num a's
     char set [xyz]  ==  one of chars in '[]'  inclg esc-seqs
     spc chars  '.'  '*'    !specl in  char set, no need to esc            can spec  a rng of chars with '-'
  [a-d]  ~ [abcd]    M ('b'| "brisket"   'c' |"city")         /[a-z.]+/ and /[\w.]+/   M    "test.i.ng"
     neg char set [^xyz]  == * !in '[]'
  * that works in the norm  char set works here  (  spec rng of chars using a '-'  )
       [^abc] ~ [^a-c]
       initially M(  'r' | "brisket"   'h' | "chop" )
      '[]' nec to mat lit bSp char  [\b]  !~ \b   ==  bSp (U+0008).
 \b == word boundary (wBd) ,  word char(wCh)

 wBd == posn wher wCh  !(folld|precd) by anthr wCh         matd wBd !incd in  mat          matd wBd len = 0          /\bm/  M   'm'|"moon"
 /oo\b/  !M 'oo' in "moon",          b/c 'oo' is followed by 'n' which is a word char
 /oon\b/  M 'oon' | "moon", b/c 'oon' is end of   str,  thus !folby  wCh
 /\w\b\w/ will never M anything,  b/c a wCh can !be folby both a non-word and a wCh


    "word" chars  solely:  up/low  Roman alph , dec  nums, '_'
   all else are word breaks ( accents "é"  "ü"  are word breaks )


 '\B':  'Mats a non-word boundary.'+
 'This mats a position where the previous and next char are of the same type: ' +
 'Either both must be words, or both must be non-words. ' + 'The beginning and end of a str are considered non-words
      /\B../ mats 'oo' in "noonday", and /y\B./ mats 'ye' in "possibly yesterday."
  \cX :    'Where X is a char ranging from A to Z'+  'Mats a control char in a str'
     /\cM/     mats control-M (U+000D) in a str.
    \d   Mats a num. Equivalent to [0-9].
     /\d/ or /[0-9]/    mats '2' in "B2 is the suite number."
 \D ~ [^0-9]    Mats any !digit char
  /\D/ ~ /[^0-9]/  mats 'B' in "B2 is the suite number."
 \f	M form feed (U+000C)        \n	Mats a line feed (U+000A)        \r	Mats a carriage return (U+000D).
 \s  == a sing wSp char, including sp, tab, form feed, line feed.
 ~ [ \f\n\r\t\v​\u00a0\u1680​\u180e\u2000​-\u200a​\u2028\u2029\u202f\u205f​\u3000].
 /\s\w*/      mats ' bar' in "foo bar."
 \S  ~ [^ \f\n\r\t\v​\u00a0\u1680​\u180e\u2000-\u200a​\u2028\u2029​\u202f\u205f​\u3000] == sing char other than wSp
  /\S\w*/  M  'foo' in "foo bar."
 \t	== tab (U+0009)      \v	== vert  tab (U+000B)
 \w ~ [A-Za-z0-9_] == any alnum  char incl '_'       /\w/            M ( 'a'|"apple"     '5'|"$5.28"    '3'|"3D" )
 \W  ~ [^A-Za-z0-9_] == any non-word char       ( /\W/       /[^A-Za-z0-9_]/  ) M '%'| "50%."
 \n  = n pos int
  back-ref   to t  last substr matg the n parenthetical in the rx  (counting left '()')
   /apple(,)\sorange\1/ mats 'apple, orange,' in "apple, orange, cherry, peach."
 \0	==  NULL (U+0000) char. !folby another num,  b/c \0<digits> is an octalesc sequence.
 \xhh	  M char with the code hh (two hexadecimal digits)
 \uhhhh	Mats the char with the code
  hhhh (four hexadecimal digits).

 Escaping user input to be treated as a lit str:     function escapeRegExp(str){  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&") }
 REMEMBERING WITH  '()'  - Parentheses around any part of the rx pt        cause that part of the matched substr to be remembered.
  Once remembered,  the substr can be recalled for other use   ills additional escaped and special chars
        indicates that part of the pt should be remembered           '()' are used to remember the 1st matched nums
    /Chapter (\d+)\.\d*/  === 'Chapter ', 1+ nums,'.',0+nums
    M "Open Chapter 4.3, paragraph 6" , '4' remembered            !M "Chapter 3 and 4" (!period after the '3')
    match a substr   without causing the matched part to be remembered,  within the '()' preface the pt with ?:.        (?:\d+) M 1+   numes but does not remember



 /////
      When you want to know whether a pt is found in a str,
           use the test or search method

           TEST   tests  mat in str, -> bool

          SEARCH
              	A String method that tests for a match in a str.
              	It returns the index of the match, or -1 if the search fails.


  for more information (but slower execution)
        use the exec or match methods

 EXEC	 seeks mat in a str, -> arr


    MATCH
     A String method that executes a search for a match in a str.
      It returns an array of information or null on a mismatch.

       If you use exec or match and if the match succeeds,
        these methods return an array
         and update properties of the associated rx ob
         and also of the predefined rx ob, RX.
          If the match fails,
           the exec method returns null
           (which coerces to false).



      myRe = /d(b+)d/g  ~ new RegExp("d(b+)d", "g")
   myArray = myRe.exec("cdbbdbsbz")
    ~ /d(b+)d/g.exec("cdbbdbsbz")

    If you  use a rx created with an ob initializer
             w/o assigning it to a var,
            every occurrence is a new rx.
     SO if you use this form without assigning it to a var,
       you cannot late access pops of that rx.

 myArray, matched str and all remembered substrs, ["dbbd", "bb"]

 index, 0-based index of the mat  in  input str,

 input,	orig str,	"cdbbdbsbz"

     [0]	The last matched chars,	"dbbd"
 myRe

 Gfg
     lastIndex: ix at which 2beg  next mat
     source: pt t, upd when rx crtd (!execd)   "d(b+)d"

   re = /d(b+)d/g
  ar  = re.exec("cdbbdbsbz");  re.lastIndex  //  5
   ar= /d(b+)d/g.exec("cdbbdbsbz");    ar2= /d(b+)d/g.lastIndex   //0
  two occs of /d(b+)d/g  are dif re-obs, so have dif lIx vals.
   var helpful for getting pops of a reOb-initialized re





 ////////////////// ()

     Using ()'-ed substr mats

 Including '()' in a rx pt:
 -causes the corresponding submatch to be remembered

  /a(b)c/
  -mats the chars 'abc'
  -remembers 'b'

  To recall these ()'-ed substr mats,
  use the Arr [1],...,[n].
  The returned array holds all that were found.
  unlimited!

     using the replace() method to switch the words in the str.
     For the replacement text, the script uses the $1 and $2
      in the replacement to denote the
      1st and 2nd ()'-ed substr mats.


     ("John Smith").replace( /(\w+)\s(\w+)/, "$2, $1")
     -> "Smith, John"




  FLAGS can be used sep/tog,  any order, cannot be added or changed later
   /pt/flags ~ new RegExp("pt", "flags")
   Global caseInsen  Multln

      stickYsearch mat begat tgstr curpos


      /\w+\s/g  seeks cmbo (1+ch,sp) in str.

     ("fee fi fo fum").match(   /\w+\s/g   ~  new RegExp("\\w+\\s", "g") )

     ["fee ", "fi ", "fo "]

       M    -> multiline input str  should be treated as mult lines.
  If  is used,   ^   $ mat at beg/end * ln  wthn ip str   (! beg/end of   entire str).




 REPLACE
  seeks mat in str , replaces substr-mat w new substr



   	SPLIT: brk str -> [substr] w rx|str

      change order in ip str, cleans a roughly formatted ip str containing ns (1st name 1st) sepby blanks,  tabs and 1 ';
         revs n  order (lN 1st),   sorts  list , n  str contains mult sp|tabs, may have mult sp  btwn 1st/last ns


   NS = "Harry Trump ;Fred Barney; Helen Rigby ; Bill Abel ; Chris Hand ";
  oup = ["- Orig S \n", ns + "\n"]  // Prepare 2 rx pts & ar  storage.  str -> arr  els   // poss wSp, then ';',  then poss  wSp
    nLs  = NS.split(   pt= /\s*;\s*/     )    //Break  str -> pt-seped pieces, stored in arr
  pt = /(\w+)\s+(\w+)/  //  1+ chs, sps, chs // Use '()' to me portions of the pt,
    bylNLs = []   // dsply n-arr 4 holdg ns being prcssd, popu new arr w ','-sep ns  // REPLACE  rm * mat   pt, repl it with   mem str—2nd mem  portion // fb comma space, fb 1st memo  portion, $1 $2 ref2 parts memd  while matg   pt

   o.push("- Aft re Split ");  var i, l;
     for (i = 0, l = nL.length; i < l; i++){
         o.push(nL[i]);        bylNLs[i] = nLs[i].replace(pt, "$2, $1") }


     o.push("- Ns Rev")
     for (i = 0, len = bylNLs.length; i < len; i++){   oup.push(bylNLs[i]); }
     bylNLs.sort(); o.push("---  Sorted")//Sort by lN, display  sorted arr
     for (i = 0, len = bylNLs.length; i < len; i++){  o.push(bylNLs[i])   }
     o.push("---  End");  $l(o.join("\n"))






  //////////////// ex:   Using special chars to verify input



         user  enters  phone num, presses the "Check" button
         -> scr  checks the validity of the num.

     valid:
         (mats the char sequence specified by the rx),
        scr shows  message thanking/confirming  num.

          invalid:
          the scr  informs the user num is not valid


         Within non-capturing '()' (?: ,

         the rx looks for three numeric chars


          \d{3}   OR | a left parenthesis

           \( followed by three digits \d{3},

          followed by a close parenthesis \),

           (end non-capturing parenthesis )
         ),

            followed by one dash,

             forward slash,

              or decimal point and when found,

              remember the char ([-\/\.]),

               followed by three digits \d{3},

                followed by the remembered match of a dash,

                 forward slash, or decimal point \1,

                  followed by four digits \d{4}.


     The Change event activated when the user presses Enter
     sets the value of RX.input.



     $.p('Enter your phone num (with area code)
            and then click Check',
             $.br(),'expected format is like ###-###-####)')
   $.f().act('#').A(
   $.ip().id('phone'),$.bt('Check', function(){
   testInfo(document.getElementById('phone'))  })})
 re = /(?:\d{3}|\(\d{3}\))([-\/\.])\d{3}\1\d{4}/
 function testInfo(phoneInput){
    OK = re.exec(phoneInput.value)
     if (!OK) {$l(OK.input +" isn't a phone num with area code!") }
     else {$l("Thanks, your phone num is " + OK[0])}}


     ///

          When you want to know whether a pt is found in a str,
               use the test or search method

               TEST   tests  mat in str, -> bool

              SEARCH
                  	A String method that tests for a match in a str.
                  	It returns the index of the match, or -1 if the search fails.


      for more information (but slower execution)
            use the exec or match methods

     EXEC	 seeks mat in a str, -> arr


        MATCH
         A String method that executes a search for a match in a str.
          It returns an array of information or null on a mismatch.

           If you use exec or match and if the match succeeds,
            these methods return an array
             and update properties of the associated rx ob
             and also of the predefined rx ob, RX.
              If the match fails,
               the exec method returns null
               (which coerces to false).



          myRe = /d(b+)d/g  ~ new RegExp("d(b+)d", "g")
       myArray = myRe.exec("cdbbdbsbz")
        ~ /d(b+)d/g.exec("cdbbdbsbz")

        If you  use a rx created with an ob initializer
                 w/o assigning it to a var,
                every occurrence is a new rx.
         SO if you use this form without assigning it to a var,
           you cannot late access pops of that rx.

     myArray, matched str and all remembered substrs, ["dbbd", "bb"]

     index, 0-based index of the mat  in  input str,

     input,	orig str,	"cdbbdbsbz"

         [0]	The last matched chars,	"dbbd"
     myRe

     Gfg
         lastIndex: ix at which 2beg  next mat
         source: pt t, upd when rx crtd (!execd)   "d(b+)d"

       re = /d(b+)d/g
      ar  = re.exec("cdbbdbsbz");  re.lastIndex  //  5
       ar= /d(b+)d/g.exec("cdbbdbsbz");    ar2= /d(b+)d/g.lastIndex   //0
      two occs of /d(b+)d/g  are dif re-obs, so have dif lIx vals.
       var helpful for getting pops of a reOb-initialized re





     ////////////////// ()

         Using ()'-ed substr mats

     Including '()' in a rx pt:
     -causes the corresponding submatch to be remembered

      /a(b)c/
      -mats the chars 'abc'
      -remembers 'b'

      To recall these ()'-ed substr mats,
      use the Arr [1],...,[n].
      The returned array holds all that were found.
      unlimited!

         using the replace() method to switch the words in the str.
         For the replacement text, the script uses the $1 and $2
          in the replacement to denote the
          1st and 2nd ()'-ed substr mats.


         ("John Smith").replace( /(\w+)\s(\w+)/, "$2, $1")
         -> "Smith, John"




      FLAGS can be used sep/tog,  any order, cannot be added or changed later
       /pt/flags ~ new RegExp("pt", "flags")
       Global caseInsen  Multln

          stickYsearch mat begat tgstr curpos


          /\w+\s/g  seeks cmbo (1+ch,sp) in str.

         ("fee fi fo fum").match(   /\w+\s/g   ~  new RegExp("\\w+\\s", "g") )

         ["fee ", "fi ", "fo "]

           M    -> multiline input str  should be treated as mult lines.
      If  is used,   ^   $ mat at beg/end * ln  wthn ip str   (! beg/end of   entire str).




     REPLACE
      seeks mat in str , replaces substr-mat w new substr



       	SPLIT: brk str -> [substr] w rx|str

          change order in ip str, cleans a roughly formatted ip str containing ns (1st name 1st) sepby blanks,  tabs and 1 ';
             revs n  order (lN 1st),   sorts  list , n  str contains mult sp|tabs, may have mult sp  btwn 1st/last ns


       NS = "Harry Trump ;Fred Barney; Helen Rigby ; Bill Abel ; Chris Hand ";
      oup = ["- Orig S \n", ns + "\n"]  // Prepare 2 rx pts & ar  storage.  str -> arr  els   // poss wSp, then ';',  then poss  wSp
        nLs  = NS.split(   pt= /\s*;\s*/     )    //Break  str -> pt-seped pieces, stored in arr
      pt = /(\w+)\s+(\w+)/  //  1+ chs, sps, chs // Use '()' to me portions of the pt,
        bylNLs = []   // dsply n-arr 4 holdg ns being prcssd, popu new arr w ','-sep ns  // REPLACE  rm * mat   pt, repl it with   mem str—2nd mem  portion // fb comma space, fb 1st memo  portion, $1 $2 ref2 parts memd  while matg   pt

       o.push("- Aft re Split ");  var i, l;
         for (i = 0, l = nL.length; i < l; i++){
             o.push(nL[i]);        bylNLs[i] = nLs[i].replace(pt, "$2, $1") }


         o.push("- Ns Rev")
         for (i = 0, len = bylNLs.length; i < len; i++){   oup.push(bylNLs[i]); }
         bylNLs.sort(); o.push("---  Sorted")//Sort by lN, display  sorted arr
         for (i = 0, len = bylNLs.length; i < len; i++){  o.push(bylNLs[i])   }
         o.push("---  End");  $l(o.join("\n"))






      //////////////// ex:   Using special chars to verify input



             user  enters  phone num, presses the "Check" button
             -> scr  checks the validity of the num.

         valid:
             (mats the char sequence specified by the rx),
            scr shows  message thanking/confirming  num.

              invalid:
              the scr  informs the user num is not valid


             Within non-capturing '()' (?: ,

             the rx looks for three numeric chars


              \d{3}   OR | a left parenthesis

               \( followed by three digits \d{3},

              followed by a close parenthesis \),

               (end non-capturing parenthesis )
             ),

                followed by one dash,

                 forward slash,

                  or decimal point and when found,

                  remember the char ([-\/\.]),

                   followed by three digits \d{3},

                    followed by the remembered match of a dash,

                     forward slash, or decimal point \1,

                      followed by four digits \d{4}.


         The Change event activated when the user presses Enter
         sets the value of RX.input.



         $.p('Enter your phone num (with area code)
                and then click Check',
                 $.br(),'expected format is like ###-###-####)')
       $.f().act('#').A(
       $.ip().id('phone'),$.bt('Check', function(){
       testInfo(document.getElementById('phone'))  })})
     re = /(?:\d{3}|\(\d{3}\))([-\/\.])\d{3}\1\d{4}/
     function testInfo(phoneInput){
        OK = re.exec(phoneInput.value)
         if (!OK) {$l(OK.input +" isn't a phone num with area code!") }
         else {$l("Thanks, your phone num is " + OK[0])}}